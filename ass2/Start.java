import java.io.*;
import java.lang.*;
import java.util.*;
import java.security.*;
import java.sql.Timestamp;
import java.math.BigInteger; 
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest; 
import java.security.NoSuchAlgorithmException; 

public class Start{


    //current amt of money which dexter has
    //hardcoded but can be changed
	private static int ACT_AMOUNT=100000;
	//total amt which dexter has to get from his friends 
	private static int TO_GET_AMOUNT;
       
	public static void main(String[] args) throws NoSuchAlgorithmException{
	    try {
			System.setIn(new FileInputStream("fxt.txt"));
			System.setOut(new PrintStream(new FileOutputStream("fotxt.txt")));
		} catch (Exception e) {
			System.err.println("Error");
		}
		Scanner sc = new Scanner(System.in);
		// int t=sc.nextInt();
		// t=1;
		
		//trxPool is set of all transactions
		HashSet<Transaction> trxPool=new HashSet<>();

		//validTrxPool is set of all validated transactions
		HashSet<Transaction> validTrxPool=new HashSet<>();

		// take input from user or use dummy (example) transactions
		//either trans generated by transactionGen.py or give inp

		Transaction dummy0=new Transaction(5000,"rohan");
		Transaction dummy1=new Transaction(5000,"anushka");
		
		System.out.println("Enter the no of transactions in input file");
		System.out.println("format of transactions:");
		System.out.println("1 AMOUNT SENDER (here Dexter is receiver)");
		System.out.println("2 AMOUNT SENDER RECEIVER");
		System.out.println();
		
		int no_of_tr=Integer.parseInt(sc.next());
		// sc.nextLine();


		//taking transaction inputs

		for(int i=0;i<no_of_tr;i++){
			// System.out.println("Name :");
			int val=sc.nextInt();
			
			Transaction t;
			if(val==1){
				// System.out.println("Name :1");
				int amt=Integer.parseInt(sc.next());
               String nm=sc.next();
               t=new Transaction(amt,nm);

			}else{
				// System.out.println("Name :2");
				int amt=Integer.parseInt(sc.next());
               String nm=sc.next();
               String rec=sc.next();
               t=new Transaction(amt,nm,rec);

			}
			// String nm=sc.nextLine();
			// System.out.println("Amount: ");
			// int amt=sc.nextInt();

			

			trxPool.add(t); 
		}
		// trxPool.add(dummy0);
		// trxPool.add(dummy1);
		
		// getAllFailedTransactions(trxPool);

		// Handling the first block

		//GENESIS BLOCK
    // for(Transaction tr: trxPool)



    ////*****************************NEWLY ADDED*************************
   System.out.println("start the algorithm");
//initialise the consensus
    Consensus consensusAlg=new Consensus();

    //create a dummy genesis block and add to all nodes to get rid of null pointer problems 
    Block genesis=new Block();
    genesis.prev=new Hash("axexbjxs");
    genesis.merkelRoot=new Hash("oopsdsaBlock");
    genesis.hsPtr=null;
    Date d=new Date();
    genesis.tm=new Timestamp(d.getTime());
    genesis.curr=new Hash(genesis);
    genesis.height=1;
    
    ArrayList<Node> nodeList=new ArrayList<>();
    //These are all the nodes in the system and as and when required we can remove or add nodes
    //Here i have started the system with 10 nodes
    for(int i=0;i<10;i++){
      Node no=new Node(new Blockchain(genesis));
      nodeList.add(no);
    }


    ArrayList<ValidatorNode> validatorList=new ArrayList<>();
    //These are the validator nodes
    //here i have started with 5 validators with random coinage,deposits and computational power
    for(int i=0;i<5;i++){
     int coinage=10;
     int deposit=30;
     int compPower=12;
      ValidatorNode no=new ValidatorNode(coinage,deposit,compPower,new Blockchain(genesis));
      nodeList.add(no);
      validatorList.add(no);

      
    }

while(trxPool.size()>0){
   //select the appropriate validator 
    ValidatorNode validator=consensusAlg.selectValidator(validatorList);
    validator.printInfo();// prints validator info

    /* proposes ,adds and broadcasts a new block and takescare of failure*/
    boolean flag=validator.funct(trxPool,nodeList);
    if(flag==false)break;
    
    validator.getBlockchain().printBlockchain();//prints blockchain present in this node.

}
////*****************************NEWLY ADDED*************************
		
	}

	//utility function to getCurrentAmount which Dexter has
	private static int getCurrentAmount(){
		System.out.println("Dexter has Rs:"+ACT_AMOUNT);
		return ACT_AMOUNT;
	} 
    
    //check if the transaction is valid and return false if it fails
	private static boolean ifValidperformTransaction(Transaction t){
		boolean ans=true;
		if(t.receiver.equalsIgnoreCase("Dexter")){
             TO_GET_AMOUNT+=t.money;
		}else{
			if(t.sender.equalsIgnoreCase("Dexter")){
                   if(ACT_AMOUNT>=t.money){
                       ACT_AMOUNT-=t.money;
                   }else{
                   	ans=false;
                   	t.rejected=true;
                   }
			}else{
                
			}
		}
		return ans;
    }
    //prints all the transactions verified
    private static void getAllCompletedTransactions(HashSet<Transaction> hs){
       for(Transaction t:hs){
       	t.printTransaction();
       }
    }

    //prints all the transactions which failed in verification
    private static void getAllFailedTransactions(HashSet<Transaction> hs){
       for(Transaction t:hs){
       	t.printTransaction();
       }
    }


}

class Transaction{
	int money;
	String sender;
	String receiver="Dexter";
	Date d;
	Timestamp t;
	boolean rejected=false;
	Transaction(){

	}
	Transaction(int money,String sender){
        this.money=money;
        this.sender=sender;
        d=new Date();
        t=new Timestamp(d.getTime());
	}
	Transaction(int money,String sender,String receiver){
        this.money=money;
        this.sender=sender;
        this.receiver=receiver;
        d=new Date();
        t=new Timestamp(d.getTime());
	}

	//printts the timestamp of this transaction
	void printTimeStamp(){
		System.out.println(t);
	}
	//prints the transaction details
	void printTransaction(){
		System.out.println(this.sender+"->"+"sent Rs"+this.money+"to " +this.receiver);
		System.out.println("Transaction time:"+t);
		// printTimeStamp();
	}

}
class Block{
	List<Transaction> li;
	Hash prev;
	Hash curr;
	Hash merkelRoot;
	// BlockHeader bh;
	Block hsPtr;
	int confirmations=0;
	Timestamp tm;
  int height;
	private static final int CAP=3;
	Block(){

	}

	Block(Hash prev,Block prevBl){
		this.prev=prev;
		this.hsPtr=prevBl;
		this.li=new ArrayList<>();
    if(prevBl!=null)this.height=prevBl.height+1;
	}


   int getCapacity(){
    return this.CAP;
   }

	//adds the transaction to the current block if transaction is valid and 
	//current block is not full 
	//if the current block is full return false
	boolean addTransaction(Transaction t) throws NoSuchAlgorithmException{
            if(this.li.size()<CAP){
                this.li.add(t);
                return true;
            }else{
            	this.merkelRoot=merkelRootCalc(this.li);
            	Date d=new Date();
                this.tm=new Timestamp(d.getTime());
            	this.confirmations+=1;
            }
            return false;
	}
	//prints info of current block
    void printBlockInfo(){
    	System.out.println("Block Hash:"+this.curr.str);
    	System.out.println("Block merkelRoot:"+this.merkelRoot);
    	// System.out.println("Block Creation time:"+this.tm);
    	System.out.println("Block confirmations"+this.confirmations);

    }

    //implementation of merkelRoot calculation in O(nlogn)
	Hash merkelRootCalc(List<Transaction> li) throws NoSuchAlgorithmException{
          List<Hash> arr=new ArrayList<>();
          // to write ie hash of each transaction
          //arr.get(i) --->leaf hash

          if(li.size()==0)return new Hash("abndjkwjkjdwodwow");
          for(int i=0;i<li.size();i++){
          	arr.add(new Hash(li.get(i)));
          }
          while(arr.size()>1){
          	// System.out.println(arr);
          	if(arr.size()%2==1){
                arr.add(arr.get(arr.size()-1));
          	}
          	// System.out.println(arr);
          	// List<Hash> al=new ArrayList<>();
          	for(int i=0;i<arr.size();i+=2){
          		// al.add(hashComp(arr.get(i),arr.get(i+1)));
          		arr.set(i/2,hashComp(arr.get(i),arr.get(i+1)));
          	}
          	int n=arr.size();
          	for(int i=n-1;i>=n/2;i--)arr.remove(arr.size()-1);

          }
          return arr.get(0);
	}
	Hash hashComp(Hash A,Hash B) throws NoSuchAlgorithmException{
        
        StringBuilder sb=new StringBuilder();
        sb.append(A.str);
        sb.append(B.str);
        Hash ans=new Hash(sb.toString());
        return ans;
	}

}

class Hash{
	String str;
	Hash(){

	}
	// Hash(Object o){
	// 	str=String.valueOf(o.hashCode());
	// }
	Hash(String st) throws NoSuchAlgorithmException{
		str=HashAlgo.func(st);
	}
	Hash(Transaction tr) throws NoSuchAlgorithmException{
	   StringBuilder sb=new StringBuilder();
	   sb.append(tr.sender);
	   sb.append(tr.receiver);
	   sb.append(tr.money);
	   // System.out.println(sb);
       str=HashAlgo.func(sb.toString());
	}
	Hash(Block b) throws NoSuchAlgorithmException{
	  StringBuilder sb=new StringBuilder();
	  // System.out.println(b.hsPtr);
    // System.out.println(b.merkelRoot);
    System.out.println(b.tm);
    System.out.println(b.prev);
    System.out.println(b.prev.str);
    System.out.println(b.merkelRoot);
    
      sb.append(b.prev.str);
    
    sb.append(b.merkelRoot.str);
  

      str=HashAlgo.func(sb.toString());
	}
}
class HashAlgo{
	
	
	HashAlgo(){
       
	}
	

    public static String func(String str) throws NoSuchAlgorithmException{
    	return toHexString(getSHA(str));
    }
	public static byte[] getSHA(String input) throws NoSuchAlgorithmException
    { 
        // Static getInstance method is called with hashing SHA 
        MessageDigest md = MessageDigest.getInstance("SHA-256"); 
  
        // digest() method called 
        // to calculate message digest of an input 
        // and return array of byte
        return md.digest(input.getBytes(StandardCharsets.UTF_8)); 
    }
    
    public static String toHexString(byte[] hash)
    {
        // Convert byte array into signum representation 
        BigInteger number = new BigInteger(1, hash); 
  
        // Convert message digest into hex value 
        StringBuilder hexString = new StringBuilder(number.toString(16)); 
  
        // Pad with leading zeros
        while (hexString.length() < 32) 
        { 
            hexString.insert(0, '0'); 
        } 
  
        return hexString.toString(); 
    }

}

////*****************************NEWLY ADDED*************************

/*every node has its own copy of the blockchain */
class Blockchain{
	Block genesis;
	
	Block last;
  Blockchain(){

  }
	Blockchain(Block b){
        // genesis= something to Do
    this.genesis=b;
    this.last=b;

	   
	}
	// sets the last block of the blockchain to be b
	void setLastBlock(Block b){
    
    this.last=b;
  }

  //return the last block of the blockchain
  Block getLastBlock(){
		return last;
	}
  //prints all blocks in the blockchain
  void printBlockchain(){
    printAllTransactions(this.last);
    return;
  }
  // prints all transactions of all the blocks before it including it 
	void printAllTransactions(Block b){
        Block tmp=b;
        int x=1;
        System.out.println("abs");
        while(tmp.equals(genesis)==false){
        	System.out.println("Block :"+x);
        	tmp.printBlockInfo();
        	x++;
        	for(Transaction t:tmp.li){
        		t.printTransaction();
        	}
        	tmp=tmp.hsPtr;
        }
	}
	//prints all transactions of the current block passed 
	void printTransactionBlock(Block b){
		b.printBlockInfo();
		for(Transaction t:b.li){
        		t.printTransaction();
        	}
	}

}

////*****************************NEWLY ADDED*************************


//Node contains various copies of the blockchain
class Node{
	Blockchain bc;
    Node(Blockchain x){
       this.bc=x;
    }
    //adds a block to the local blockchain after validation when broadcasted
    Hash addBlock(Block b) throws NoSuchAlgorithmException{
    // super.bc.add(block)

    b.merkelRoot=b.merkelRootCalc(b.li);
    b.curr=new Hash(b);
    this.bc.setLastBlock(b);
   return b.curr;
  }

}
////*****************************NEWLY ADDED*************************

//These are special nodes that propose the new blocks and broadcast to all nodes for verifying
class ValidatorNode extends Node{
	
  int coinage=0;
  int deposit=0;
  int compPower=1;
  Block bl;

  ValidatorNode(int coinage,int deposit,int compPower,Blockchain bc){
         super(bc);
         this.coinage=coinage;
         this.deposit=deposit;
         this.compPower=compPower;
	}
  //prints the basic information of a node
  void printInfo(){
    System.out.println("Node coinage="+this.coinage);
    System.out.println("Node deposit="+this.deposit);
    System.out.println("Node compPower="+this.compPower);
    // System.out.println("Node Id="+this.);
  }
  //returns the blockchain present in this node
  Blockchain getBlockchain(){
    return super.bc;
  }
  /*this function returns false when a block is half filled else it creates block and 
  adds new block and proposes to all the nodes by broadcasting*/
  boolean funct(HashSet<Transaction> hs,ArrayList<Node> nodeList) throws NoSuchAlgorithmException{
    Block b=createBlock(hs);
    System.out.println(b.li.size()+"xxxxxxxxx");
    if(b.li.size()<b.getCapacity()){return false;}
    super.addBlock(b);

    this.bl=b;
    broadcastBlock(bl,nodeList);
    return true;
  }
  //creates a new block by adding the transactions to the block
  Block createBlock(HashSet<Transaction> hs) throws NoSuchAlgorithmException{
     Block prev=super.bc.getLastBlock();
     Block b=null;
     if(prev!=null)b=new Block(new Hash(prev),prev);
       ArrayList<Transaction> arr=new ArrayList<>();
     for(Transaction tr: hs){
        arr.add(tr);
     }
     for(int i=0;i<arr.size();i++){
      if(b.addTransaction(arr.get(i))==false)break;
      else{
          hs.remove(arr.get(i));
      }
     }
     return b;
  }

  /*broadcasts the proposed block to all the nodes on more than 3 
  confirmations this block is added to the blockchain but if rejected the blockchain in this is 
  brought back to correct state*/
  void broadcastBlock(Block b,ArrayList<Node> nodeList) throws NoSuchAlgorithmException{
    for(Node n: nodeList){
      if(b.confirmations<=3){
        
      if(n.addBlock(b).equals(bl.curr.str)){
          b.confirmations+=1;
      }else{
         //reject the block and get back to correct state of blockchain; 
        if(super.bc.getLastBlock().hsPtr!=null){
          super.bc.setLastBlock(super.bc.getLastBlock().hsPtr);
        }
        // super.bc.setLastBlock(b);
      }
    }else{

      n.addBlock(b);
  }
    }
    }

//check and gives the node with correct chain in case of ambiguity of multiple chains
    Node findCorrectChain(ArrayList<Node> al){
      int val=0;
      Block blo;
      Node n=null;
      for(int i=0;i<al.size();i++){
         Block b=al.get(i).bc.getLastBlock();
         if(b.height>val){
          blo=b;
          val=b.height;
          n=al.get(i);
         }
      }
      return n;
    }


}
////*****************************NEWLY ADDED*************************
class Consensus{

    Consensus(){

    }
    /* returns the node with correct state of blockchain
     in times of confusion using the longest chain rule  */
    Node findCorrectChain(ArrayList<Node> al){
      int val=0;
      Block blo;
      Node n=null;
      for(int i=0;i<al.size();i++){
         Block b=al.get(i).bc.getLastBlock();
         if(b.height>val){
          blo=b;
          val=b.height;
          n=al.get(i);
         }
      }
      return n;
    }
      
    /* returns the validator based on the stake and randomization criterias
    1.coinage
    2.deposit
    3.compPower
    */
    ValidatorNode selectValidator(ArrayList<ValidatorNode> al){
      
     ValidatorNode n=findMaxStake(al);
     return n;

    }
    //selects the validator on the basis of random criteria
    ValidatorNode findMaxStake(ArrayList<ValidatorNode> al){
             int choice=(int)(4.0*Math.random());
             if(choice==1){
               return stakeByCoinage(al); 
             }else if(choice==2){
               return stakeByComputationPower(al);
             }
             
             return stakeByDeposit(al);
    }

    //selects the validator based on coinage
    ValidatorNode stakeByCoinage(ArrayList<ValidatorNode> al){
     ValidatorNode aux=al.get(0);
      for(int i=1;i<al.size();i++){
      	if(al.get(i).coinage>aux.coinage){
      		aux=al.get(i);
      	}
      }
      aux.coinage-=aux.coinage/2;
      return aux;

    }
    //selects the validator based on computation power of validators
    ValidatorNode stakeByComputationPower(ArrayList<ValidatorNode> al){
    	ValidatorNode aux=al.get(0);
      for(int i=1;i<al.size();i++){
      	if(al.get(i).compPower>aux.compPower){
      		aux=al.get(i);
      	}
      }
      return aux;

    }
    //selects the validator based on deposit put by the validator to perform additon of blocks
    ValidatorNode stakeByDeposit(ArrayList<ValidatorNode> al){
    	ValidatorNode aux=al.get(0);
      for(int i=1;i<al.size();i++){
      	if(al.get(i).deposit>aux.deposit){
      		aux=al.get(i);
      	}
      }
      aux.deposit-=aux.deposit/2;
      return aux;
    	
    }

}